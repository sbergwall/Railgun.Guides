# Install SCOM 2022

## Links
https://learn.microsoft.com/en-us/system-center/scom/?view=sc-om-2022
https://kevinholman.com/2022/05/01/scom-2022-quickstart-deployment-guide/
https://www.youtube.com/watch?v=-M4PnyIqwZc
https://learn.microsoft.com/en-us/system-center/scom/plan-sqlserver-design?view=sc-om-2022


## Create Active Directory Service Accounts & Groups

### Service Accounts
```powershell
$OU = "OU=ServiceAccount,OU=Users,OU=company,DC=company,DC=pri"

$scomAction = Get-Credential -Message "Name and password for SCOM Action Account"
$scomDataAccessService = Get-Credential -Message "Name and password for SCOM Data Access Service Account"
$scomDataReader = Get-Credential -Message "Name and password for SCOM Data Reader Account"
$scomDataWriter = Get-Credential -Message "Name and password for SCOM Data Writer Account"
$scomReport = Get-Credential -Message "Name and password for SCOM Report Account"
$scomDatabase = Get-Credential -Message "Name and password for SCOM SQL Server DB Account"
$scomDatabaseAgent = Get-Credential -Message "Name and password for SCOM SQL Server DB Agent Account"


New-ADUser -SamAccountName $scomAction.UserName -Name $scomAction.UserName -Path $OU -Description "SCOM Management Server Action Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomAction.Password -DisplayName $scomAction.UserName -Enabled $true -UserPrincipalName ($scomAction.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomDataAccessService.UserName -Name $scomDataAccessService.UserName -Path $OU -Description "SCOM Management SCP; Service amd Data Access Service" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomDataAccessService.Password -DisplayName $scomDataAccessService.UserName -Enabled $true -UserPrincipalName ($scomDataAccessService.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomDataReader.UserName -Name $scomDataReader.UserName -Path $OU -Description "SCOM Data Reader Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomDataReader.Password -DisplayName $scomDataReader.UserName -Enabled $true -UserPrincipalName ($scomDataReader.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomDataWriter.UserName -Name $scomDataWriter.UserName -Path $OU -Description "SCOM Management Data Writer Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomDataWriter.Password -DisplayName $scomDataWriter.UserName -Enabled $true -UserPrincipalName ($scomDataWriter.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomReport.UserName -Name $scomReport.UserName -Path $OU -Description "SCOM Management Report Server Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomReport.Password -DisplayName $scomReport.UserName -Enabled $true -UserPrincipalName ($scomReport.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomDatabase.UserName -Name $scomDatabase.UserName -Path $OU -Description "SCOM DB Service Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomDatabase.Password -DisplayName $scomDatabase.UserName -Enabled $true -UserPrincipalName ($scomDatabase.UserName + "@" + $env:USERDNSDOMAIN)

New-ADUser -SamAccountName $scomDatabaseAgent.UserName -Name $scomDatabaseAgent.UserName -Path $OU -Description "SCOM DB Agent Service Account" -CannotChangePassword $true -PasswordNeverExpires $true -AccountPassword $scomDatabaseAgent.Password -DisplayName $scomDatabaseAgent.UserName -Enabled $true -UserPrincipalName ($scomDatabaseAgent.UserName + "@" + $env:USERDNSDOMAIN)
```

### Group and membership
```powershell
$GroupUO = "OU=SCOM,OU=Groups,OU=company,DC=company,DC=pri"
$scomAdminGroup = "scom-admins"
New-ADGroup -Name $scomAdminGroup -SamAccountName $scomAdminGroup -GroupCategory Security -GroupScope Global -DisplayName $scomAdminGroup -Path $GroupUO -Description "SCOM administrators"
Add-ADGroupMember -Identity $scomAdminGroup -Members $scomAction.UserName,$scomDataAccessService.UserName,"siber-da"

Lets add the scom admin group to local administrators on the SCOM server.
Invoke-Command -ComputerName "scom1" -ScriptBlock {Add-LocalGroupMember -Group "Administrators" -Member $using:scomAdminGroup}
```

## SQL Server 2022

### SQL Server drivers
The OLE DB and ODBC SQL Server Drivers need to be installed on all management servers and the web console server, as these components directly interface with the databases and these drivers allow API level access to SQL.

It is recommended to utilize an encrypted SQL Server connection; when doing so, you need to install the latest versions of the SQL drivers:

Microsoft OLE DB Driver latest version. https://aka.ms/downloadmsoledbsql
Microsoft ODBC Driver latest version. https://aka.ms/downloadmsodbcsql
More information about configuring SQL connection encryption can be found here: Configure SQL Server Database Engine for encrypting connections https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/configure-sql-server-encryption

If not utilizing encrypted SQL connections, use previous releases of the SQL drivers that do not enforce encryption: 

Microsoft ODBC Driver version 17.10.6. https://learn.microsoft.com/en-us/sql/connect/odbc/windows/release-notes-odbc-sql-server-windows?view=sql-server-ver16#17106&preserve-view=true
Microsoft OLE DB Driver version 18.7.4. https://learn.microsoft.com/en-us/sql/connect/oledb/release-notes-for-oledb-driver-for-sql-server?view=sql-server-ver16#1874&preserve-view=true

### Enginge 
```powershell
$Path = "C:\tmp\SQL-Server-2022"
$Version = "2022"

$eCredential = Get-Credential -Message "Credentials for Engine Service account"
$aCredential = Get-Credential -Message "Credentials for Agent Service account"
$saCredential = Get-Credential -Message "Credentials for SA account" 

Install-DbaInstance -Version $Version -Feature Default -Path $Path -InstancePath C:\SQL\Program -DataPath C:\SQL\Data -LogPath C:\SQL\Logs -TempPath C:\SQL\TempDB -BackupPath C:\SQL\Backups -EngineCredential $eCredential -AgentCredential $aCredential -SaCredential $saCredential -PerformVolumeMaintenanceTasks -AuthenticationMode Mixed -ProductID 22222-00000-00000-00000-00000 -Verbose
```

### Install Reporting Services
Download from https://www.microsoft.com/en-sg/download/details.aspx?id=104502&msockid=37374001831e64a41da1561e823665d3
Install manually.
When its done click COnfigure Report Server > choose the name of the scom server > Connect.
Service Account > User anothe account > company\scom-report > Apply.

Database > Change Database > Create a new report server database > select scom server > Next >  Next >  Next > Finish. 

Web service URL > Apply. 

Web Portal URL > Apply.

Execution Account > change to scom-report > Apply

### Install Updates
Verify that you are running the latest SQL Server version, if not update.

## Install IIS on any management server that will also host a web console:

    Open PowerShell (as an administrator) and run the following:

Add-WindowsFeature NET-WCF-HTTP-Activation45,Web-Static-Content,Web-Default-Doc,Web-Dir-Browsing,Web-Http-Errors,Web-Http-Logging,Web-Request-Monitor,Web-Filtering,Web-Stat-Compression,Web-Mgmt-Console,Web-Metabase,Web-Asp-Net,Web-Windows-Auth -Restart

    Note:  The server needs to be restarted at this point, even if you are not prompted to do so.  If you do not reboot, you will get false failures about prerequisites missing for ISAPI/CGI/ASP.net registration.


## Install SCOM

Start setup.exe as administrator. Press Install > Select the features you want to install, for a single node select all > Next > Next > If errors occurs, read the error and fix it. > choose to create the first management server in a new management group.  Give your management group a name. Dont use any special or Unicode characters, just simple text.  KEEP YOUR MANAGEMENT GROUP NAME SHORT AND SIMPLE, and DO NOT put version info in there.  I typically use “SCOM1” as this is short, simple, and readily expandable in the future to additional management groups. Click Next. > Accept the license.  Next. > On the Configure the Operational Database screen, enter in the name of your SQL database server name and instance. In this case this is "scom1.company.pri" . Leave the port at default unless you are using a special custom fixed port.  If necessary, change the database locations for the DB and log files. Leave the default size of 1000 MB for now. Click Next. > On the Configure the Data Warehouse Database screen, enter in the name of your SQL database server name and instance. In this case this is “scom1.company.pri”. Leave the port at default unless you are using a special custom fixed port.  If necessary, change the database locations for the DB and log files. Leave the default size of 1000 MB for now. Click Next. > Verify that SSRS is SCOM1\SSRS. Next > Press Next on the web sute > select Mixed, press Next > add your accounts, press Next > Press Next > select On for Windows Update, press Next > Press Install. 

### Troubleshooting installation

If you get:
Error:	:PopulateUserRoles: failed : Threw Exception.Type: System.ArgumentException, Exception Error Code: 0x80070057, Exception.Message: Value does not fall within the expected range.

Run below powershell script to get the current TLS settings:


Function Get-TLSRegistryKeys
{
	[CmdletBinding()]
	Param
	(
		[string[]]$Servers
	)
	function Write-Console
	{
		param
		(
			[string]$Text,
			$ForegroundColor,
			[switch]$NoNewLine
		)
		
		if ([Environment]::UserInteractive)
		{
			if ($ForegroundColor)
			{
				Write-Host $Text -ForegroundColor $ForegroundColor -NoNewLine:$NoNewLine
			}
			else
			{
				Write-Host $Text -NoNewLine:$NoNewLine
			}
		}
		else
		{
			Write-Output $Text
		}
	}
	
	if (!$Servers)
	{
		$Servers = $env:COMPUTERNAME
	}
	$Servers = $Servers | Sort-Object
	Write-Console "  Accessing Registry on:`n" -NoNewline -ForegroundColor Gray
	$scriptOut = $null
	function Inner-TLSRegKeysFunction
	{
		[CmdletBinding()]
		param ()
		function Write-Console
		{
			param
			(
				[string]$Text,
				$ForegroundColor,
				[switch]$NoNewLine
			)
			if ($ForegroundColor)
			{
				Write-Host $Text -ForegroundColor $ForegroundColor -NoNewLine:$NoNewLine
			}
			else
			{
				Write-Host $Text -NoNewLine:$NoNewLine
			}
		}
		$finalData = @()
		$ProtocolList = "TLS 1.0", "TLS 1.1", "TLS 1.2", "TLS 1.3"
		$ProtocolSubKeyList = "Client", "Server"
		$DisabledByDefault = "DisabledByDefault"
		$Enabled = "Enabled"
		$registryPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\"
		Write-Output "Computer Name`n-------------`n$env:COMPUTERNAME`n"
		Write-Output "Path`n----`n$registryPath"
		foreach ($Protocol in $ProtocolList)
		{
			foreach ($key in $ProtocolSubKeyList)
			{
				Write-Console "-" -NoNewline -ForegroundColor Green
				#Write-Console "Checking for $protocol\$key"
				$currentRegPath = $registryPath + $Protocol + "\" + $key
				$IsDisabledByDefault = @()
				$IsEnabled = @()
				$localresults = @()
				if (!(Test-Path $currentRegPath))
				{
					$IsDisabledByDefault = "DoesntExist"
					$IsEnabled = "DoesntExist"
				}
				else
				{
					$IsDisabledByDefault = (Get-ItemProperty -Path $currentRegPath -Name $DisabledByDefault -ErrorAction 0).DisabledByDefault
					if ($IsDisabledByDefault -eq 4294967295)
					{
						$IsDisabledByDefault = "0xffffffff"
					}
					if ($null -eq $IsDisabledByDefault)
					{
						$IsDisabledByDefault = "DoesntExist"
					}
					$IsEnabled = (Get-ItemProperty -Path $currentRegPath -Name $Enabled -ErrorAction 0).Enabled
					if ($IsEnabled -eq 4294967295)
					{
						$isEnabled = "0xffffffff"
					}
					if ($null -eq $IsEnabled)
					{
						$IsEnabled = "DoesntExist"
					}
				}
				$localresults = "PipeLineKickStart" | Select-Object @{ n = 'Protocol'; e = { $Protocol } },
																	@{ n = 'Type'; e = { $key } },
																	@{
					n = 'DisabledByDefault'; e = {
						$output = ($IsDisabledByDefault).ToString()
						if ($output -match "0|1")
						{
							$output.Replace('0', 'False').Replace('1', 'True')
						}
						elseif ($output -eq '$0xffffffff')
						{
							"$output (True)"
						}
						else
						{
							$output
						}
						
					}
				},
																	@{
					n = 'IsEnabled'; e = {
						$output = ($IsEnabled).ToString()
						if ($output -match "0|1")
						{
							$output.Replace('0', 'False').Replace('1', 'True')
						}
						elseif ($output -eq '$0xffffffff')
						{
							"$output (True)"
						}
						else
						{
							$output
						}
						
					}
				}
				$finalData += $localresults
			}
		}
		$results += $finaldata | Select-Object -Property * -ExcludeProperty PSComputerName, RunspaceId, PSShowComputerName | Format-Table * -AutoSize
		$CrypKey1 = "HKLM:\SOFTWARE\Microsoft\.NETFramework\v4.0.30319"
		$CrypKey2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319"
		$Strong = "SchUseStrongCrypto"
		$Crypt1 = (Get-ItemProperty -Path $CrypKey1 -Name $Strong -ErrorAction 0).SchUseStrongCrypto
		If ($crypt1 -eq 1)
		{
			$Crypt1 = $true
		}
		else
		{
			$Crypt1 = $False
		}
		$crypt2 = (Get-ItemProperty -Path $CrypKey2 -Name $Strong -ErrorAction 0).SchUseStrongCrypto
		if ($crypt2 -eq 1)
		{
			$Crypt2 = $true
		}
		else
		{
			$Crypt2 = $False
		}
		$DefaultTLSVersions = (Get-ItemProperty -Path $CrypKey1 -Name $Strong -ErrorAction 0).SystemDefaultTlsVersions
		If ($DefaultTLSVersions -eq 1)
		{
			$DefaultTLSVersions = $true
		}
		else
		{
			$DefaultTLSVersions = $False
		}
		$DefaultTLSVersions64 = (Get-ItemProperty -Path $CrypKey2 -Name $Strong -ErrorAction 0).SystemDefaultTlsVersions
		if ($DefaultTLSVersions64 -eq 1)
		{
			$DefaultTLSVersions64 = $true
		}
		else
		{
			$DefaultTLSVersions64 = $False
		}
		##  ODBC : https://www.microsoft.com/en-us/download/details.aspx?id=50420
		##  OLEDB : https://docs.microsoft.com/en-us/sql/connect/oledb/download-oledb-driver-for-sql-server?view=sql-server-ver15
		[string[]]$data = (Get-CimInstance -ClassName Win32_Product | Where-Object { $_.Name -like "*sql*" }).name
		$odbcOutput = $data | Where-Object { $_ -like "Microsoft ODBC Driver *" } # Need to validate version
		$odbc = @()
		foreach ($driver in $odbcOutput)
		{
			Write-Console '-' -NoNewline -ForegroundColor Green
			if ($driver -match "11|13|17|18")
			{
				Write-Verbose "FOUND $driver"
				$odbc += "$driver (Good)"
			}
			elseif ($driver)
			{
				Write-Verbose "FOUND $driver"
				$odbc += "$driver"
			}
			else
			{
				$odbc = "Not Found."
			}
		}
		$odbc = $odbc -split "`n" | Out-String -Width 2048
		$oledb = $data | Where-Object { $_ -like "Microsoft OLE DB Driver*" }
		if ($oledb)
		{
			Write-Verbose "Found: $oledb"
			$OLEDB_Output = @()
			foreach ($software in $oledb)
			{
				if ($software -eq 'Microsoft OLE DB Driver 19 for SQL Server')
				{
					$OLEDB_Output += "$software - $((Get-ItemProperty HKLM:\SOFTWARE\Microsoft\MSOLEDBSQL19).InstalledVersion) (Good)"
				}
				elseif ($software -eq 'Microsoft OLE DB Driver for SQL Server')
				{
					$OLEDB_Output += "$software - $((Get-ItemProperty HKLM:\SOFTWARE\Microsoft\MSOLEDBSQL).InstalledVersion) (Good)"
				}
				else
				{
					$OLEDB_Output += "$software - $((Get-ItemProperty HKLM:\SOFTWARE\Microsoft\MSOLEDBSQL*).InstalledVersion) (Good)"
				}
			}
		}
		else
		{
			$OLEDB = "Not Found."
		}
		foreach ($Protocol in $ProtocolList)
		{
			Write-Console '-' -NoNewline -ForegroundColor Green
			foreach ($key in $ProtocolSubKeyList)
			{
				#Write-Console "Checking for $protocol\$key"
				$currentRegPath = $registryPath + $Protocol + "\" + $key
				$IsDisabledByDefault = @()
				$IsEnabled = @()
				$localresults = @()
				if (!(Test-Path $currentRegPath))
				{
					$IsDisabledByDefault = "Not Present"
					$IsEnabled = "Not Present"
				}
				else
				{
					$IsDisabledByDefault = (Get-ItemProperty -Path $currentRegPath -Name $DisabledByDefault -ErrorAction 0).DisabledByDefault
					if ($IsDisabledByDefault -eq 4294967295)
					{
						$IsDisabledByDefault = "0xffffffff"
					}
					if ($null -eq $IsDisabledByDefault)
					{
						$IsDisabledByDefault = "DoesntExist"
					}
					$IsEnabled = (Get-ItemProperty -Path $currentRegPath -Name $Enabled -ErrorAction 0).Enabled
					if ($IsEnabled -eq 4294967295)
					{
						$isEnabled = "0xffffffff"
					}
					if ($null -eq $IsEnabled)
					{
						$IsEnabled = "DoesntExist"
					}
				}
				$localresults = "PipeLineKickStart" | Select-Object @{ n = 'Protocol'; e = { $Protocol } },
																	@{ n = 'Type'; e = { $key } },
																	@{ n = 'DisabledByDefault'; e = { ($IsDisabledByDefault).ToString().Replace('0', 'False').Replace('1', 'True') } },
																	@{ n = 'IsEnabled'; e = { ($IsEnabled).ToString().Replace('0', 'False').Replace('1', 'True') } }
				$finalData += $localresults
			}
		}
		### Check if SQL Client is installed 
		$RegPath = "HKLM:SOFTWARE\Microsoft\SQLNCLI11"
		IF (Test-Path $RegPath)
		{
			[string]$SQLClient11VersionString = (Get-ItemProperty $RegPath)."InstalledVersion"
			[version]$SQLClient11Version = [version]$SQLClient11VersionString
		}
		[version]$MinSQLClient11Version = [version]"11.4.7001.0"
		Write-Console '-' -NoNewline -ForegroundColor Green
		$SQLClientProgramVersion = $data | Where-Object { $_ -like "Microsoft SQL Server 2012 Native Client" } # Need to validate version
		IF ($SQLClient11Version -ge $MinSQLClient11Version)
		{
			Write-Verbose "SQL Client - is installed and version: ($SQLClient11VersionString) and greater or equal to the minimum version required: (11.4.7001.0)"
			$SQLClient = "$SQLClientProgramVersion $SQLClient11Version (Good)"
		}
		ELSEIF ($SQLClient11VersionString)
		{
			Write-Verbose "SQL Client - is installed and version: ($SQLClient11VersionString) but below the minimum version of (11.4.7001.0)."
			$SQLClient = "$SQLClientProgramVersion $SQLClient11VersionString (Below minimum)"
		}
		ELSE
		{
			Write-Verbose "    SQL Client - is NOT installed."
			$SQLClient = "Not Found."
		}
		###################################################
		# Test .NET Framework version on ALL servers
		# Get version from registry
		$NetVersion = @()
		$RegPath = "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\"
		$ReleaseRegValues = (Get-ItemProperty $RegPath)
		foreach ($ReleaseRegValue in $ReleaseRegValues)
		{
            <#
			# Interpret .NET version
			[string]$VersionString = switch ($ReleaseRegValue)
			{
				"378389" { ".NET Framework 4.5" }
				"378675" { ".NET Framework 4.5.1" }
				"378758" { ".NET Framework 4.5.1" }
				"379893" { ".NET Framework 4.5.2" }
				"393295" { ".NET Framework 4.6" }
				"393297" { ".NET Framework 4.6" }
				"394254" { ".NET Framework 4.6.1" }
				"394271" { ".NET Framework 4.6.1" }
				"394802" { ".NET Framework 4.6.2" }
				"394806" { ".NET Framework 4.6.2" }
				"460798" { ".NET Framework 4.7" }
				"460805" { ".NET Framework 4.7" }
				"461308" { ".NET Framework 4.7.1" }
				"461310" { ".NET Framework 4.7.1" }
				"461814" { ".NET Framework 4.7.2" }
				"461808" { ".NET Framework 4.7.2" }
				"461814" { ".NET Framework 4.7.2" }
				"528040" { ".NET Framework 4.8" }
				"528372" { ".NET Framework 4.8" }
				"528049" { ".NET Framework 4.8" }
				"528449" { ".NET Framework 4.8" }
				default { "Unknown .NET version: $ReleaseRegValue" }
			}
            #>
			Write-Console '-' -NoNewline -ForegroundColor Green
			# Check if version is 4.6 or higher
			IF ($ReleaseRegValue.Release -ge 393295)
			{
				Write-Verbose ".NET version is 4.6 or later (Detected: $($ReleaseRegValue.Version)) (Good)"
				$NetVersion += ".NET Framework $($ReleaseRegValue.Version) (Good)"
			}
			ELSE
			{
				Write-Verbose ".NET version is NOT 4.6 or later (Detected: $ReleaseRegValue.Version) (Bad)"
				$NetVersion += ".NET Framework $($ReleaseRegValue.Version) (Does not match required version, .NET 4.6 ATLEAST is required)"
			}
		}
		$SChannelLogging = Get-ItemProperty 'HKLM:\System\CurrentControlSet\Control\SecurityProviders\SCHANNEL' -Name EventLogging | Select-Object EventLogging -ExpandProperty EventLogging
		$SChannelSwitch = switch ($SChannelLogging)
		{
			1 { '0x0001 - Log error messages. (Default)' }
			2 { '0x0002 - Log warnings. (Modified)' }
			3 { '0x0003 - Log warnings and error messages. (Modified)' }
			4 { '0x0004 - Log informational and success events. (Modified)' }
			5 { '0x0005 - Log informational, success events and error messages. (Modified)' }
			6 { '0x0006 - Log informational, success events and warnings. (Modified)' }
			7 { '0x0007 - Log informational, success events, warnings, and error messages (all log levels). (Modified)' }
			0 { '0x0000 - Do not log. (Modified)' }
			default { "$SChannelLogging - Unknown Log Level Possibly Misconfigured. (Modified)" }
		}
		try
		{
			Write-Console '-' -NoNewline -ForegroundColor Green
			$odbcODBCDataSources = Get-ItemProperty 'HKLM:\SOFTWARE\ODBC\ODBC.INI\ODBC Data Sources' -ErrorAction Stop | Select-Object OpsMgrAC -ExpandProperty OpsMgrAC -ErrorAction Stop
		}
		catch { $odbcODBCDataSources = 'Not Found.' }
		try
		{
			$odbcOpsMgrAC = Get-ItemProperty 'HKLM:\SOFTWARE\ODBC\ODBC.INI\OpsMgrAC' -ErrorAction Stop | Select-Object Driver -ExpandProperty Driver -ErrorAction Stop
		}
		catch { $odbcOpsMgrAC = 'Not Found.' }
		try
		{
			$SSLCiphers = ((Get-ItemProperty 'HKLM:\SOFTWARE\Policies\Microsoft\Cryptography\Configuration\SSL\00010002').Functions).Split(",") | Sort-Object | Out-String
		}
		catch { $SSLCiphers = 'Not Found' }
		try
		{
			$FIPS = Get-ItemProperty "HKLM:\System\CurrentControlSet\Control\LSA\FIPSAlgorithmPolicy" | Select-Object Enabled, PSPath
		}
		catch
		{
			$FIPS = 'PipelineKickstart' | Select-Object @{ n = 'Enabled'; e = { 'Not Found.' } }, @{ n = 'PSPath'; e = { 'HKLM:\System\CurrentControlSet\Control\LSA\FIPSAlgorithmPolicy' } }
		}
		$additional = ('PipeLineKickStart' | Select-Object @{ n = 'SchUseStrongCrypto'; e = { $Crypt1 } },
														   @{ n = 'SchUseStrongCrypto_WOW6432Node'; e = { $Crypt2 } },
														   @{ n = 'FIPS Enabled'; e = { ($FIPS.Enabled).ToString().Replace("0", "False").Replace("1", "True") } },
														   @{ n = 'DefaultTLSVersions'; e = { $DefaultTLSVersions } },
														   @{ n = 'DefaultTLSVersions_WOW6432Node'; e = { $DefaultTLSVersions64 } },
														   @{ n = 'OLEDB'; e = { $OLEDB_Output -split "`n" | Out-String -Width 2048 } },
														   @{ n = 'ODBC'; e = { $odbc } },
														   @{ n = 'ODBC (ODBC Data Sources\OpsMgrAC)'; e = { $odbcODBCDataSources } },
														   @{ n = 'ODBC (OpsMgrAC\Driver)'; e = { $odbcOpsMgrAC } },
														   @{ n = 'SQLClient'; e = { $SQLClient } },
														   @{ n = '.NetFramework'; e = { $NetVersion -split "`n" | Out-String -Width 2048 } },
														   @{ n = 'SChannel Logging'; e = { $SChannelSwitch } },
														   @{ n = 'SSL Cipher Suites'; e = { $SSLCiphers } }
		)
		$results += $additional | Select-Object -Property * -ExcludeProperty PSComputerName, RunspaceId, PSShowComputerName
		$results += "====================================================="
		return $results
	}
	foreach ($server in $servers)
	{
		Write-Console "     $server" -NoNewline -ForegroundColor Cyan
		if ($server -notcontains $env:COMPUTERNAME)
		{
			$InnerTLSRegKeysFunctionScript = "function Inner-TLSRegKeysFunction { ${function:Inner-TLSRegKeysFunction} }"
			$scriptOut += (Invoke-Command -ComputerName $server -ArgumentList $InnerTLSRegKeysFunctionScript, $VerbosePreference -ScriptBlock {
					Param ($script,
						$VerbosePreference)
					. ([ScriptBlock]::Create($script))
					function Write-Console
					{
						param
						(
							[string]$Text,
							$ForegroundColor,
							[switch]$NoNewLine
						)
						if ($ForegroundColor)
						{
							Write-Host $Text -ForegroundColor $ForegroundColor -NoNewLine:$NoNewLine
						}
						else
						{
							Write-Host $Text -NoNewLine:$NoNewLine
						}
					}
					Write-Console "-" -NoNewLine -ForegroundColor Green
					if ($VerbosePreference -eq 'Continue')
					{
						return Inner-TLSRegKeysFunction -Verbose
					}
					else
					{
						return Inner-TLSRegKeysFunction
					}
				} -HideComputerName | Out-String) -replace "RunspaceId.*", ""
			Write-Console "> Completed!`n" -NoNewline -ForegroundColor Green
		}
		else
		{
			Write-Console "-" -NoNewLine -ForegroundColor Green
			if ($VerbosePreference -eq 'Continue')
			{
				$scriptOut += Inner-TLSRegKeysFunction -Verbose
			}
			else
			{
				$scriptOut += Inner-TLSRegKeysFunction
			}
			Write-Console "> Completed!`n" -NoNewline -ForegroundColor Green
		}
	}
	$scriptOut | Out-String -Width 4096
}


### Configuration after setup

#### Security
Add scom-admins to the SCOM Administrators User Role.  Ensure you, your team, and the SCOM DAS and Action accounts are members of this group FIRST.  
Then, remove BUILTIN\Administrators from the Operations Manager Administrators – User Role, to secure your SCOM installation.

#### Apply Updates
Apply the latest Update Rollup and restart your server. If you have a WSUS, verify that WSUS is pulling updates for SCOM.

#### Enable proxy as a default setting 
The default setting for new SCOM agents is that Agent Proxy is disabled.  You can enable this agent by agent, or for specific agents with script automations.  I find this to be a clumsy task, and more and more management packs require this capability to be enabled, like Active Directory, SharePoint, Exchange, Clustering, Skype, etc.  At some point, it makes a lot more sense to just enable this as a default setting, and that is what I advise my customers.

```powershell
add-pssnapin "Microsoft.EnterpriseManagement.OperationsManager.Client"
new-managementGroupConnection -ConnectionString:localhost
set-location "OperationsManagerMonitoring::"
Set-DefaultSetting -Name HealthService\ProxyingEnabled -Value True
```

#### Create SPN for SQL Server
Links:
https://kevinholman.com/2011/08/08/opsmgr-2012-what-should-the-spns-look-like/

```powershell
Test-DbaSpn scom1 | Set-DbaSpn 
```

Error: The service principal name (SPN) for the "System Center Data Access" service may have failed to register. The "System Center Data Access" service must register SPNs for the Operations console and other SDK clients to authenticate using Kerberos.
Solution:
```powershell
setspn -A  MSOMSdkSvc/SCOM1 COMPANY\scom-dataaccess
setspn -A  MSOMSdkSvc/SCOM1.COMPANY.PRI COMPANY\scom-dataaccess
```

## Agents
Lets push a agent to a member server. Open the console > Administration > Device Management > right click Agent Managed > Discovery Wizard > select Windows Computers, press Next > select Automatic computer Discovery, press Next > select Use selected Management Server Action Account, press Discover >

